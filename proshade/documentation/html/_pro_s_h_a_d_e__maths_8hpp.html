<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ProSHADE: src/proshade/ProSHADE_maths.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Logo_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ProSHADE
   &#160;<span id="projectnumber">0.7.5.4 (MAR 2021)</span>
   </div>
   <div id="projectbrief">Protein Shape Detection</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('_pro_s_h_a_d_e__maths_8hpp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ProSHADE_maths.hpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This header file declares all the functions required for computing various information from the ProSHADE data.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="_pro_s_h_a_d_e__misc_8hpp_source.html">ProSHADE_misc.hpp</a>&quot;</code><br />
</div>
<p><a href="_pro_s_h_a_d_e__maths_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pro_s_h_a_d_e__internal__spheres_1_1_pro_s_h_a_d_e__rot_fun__sphere.html">ProSHADE_internal_spheres::ProSHADE_rotFun_sphere</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains all inputed data for the rotation function angle-axis converted spheres.  <a href="class_pro_s_h_a_d_e__internal__spheres_1_1_pro_s_h_a_d_e__rot_fun__sphere.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_pro_s_h_a_d_e__internal__maths_1_1_bicubic_interpolator.html">ProSHADE_internal_maths::BicubicInterpolator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_pro_s_h_a_d_e__internal__spheres"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__spheres.html">ProSHADE_internal_spheres</a></td></tr>
<tr class="memdesc:namespace_pro_s_h_a_d_e__internal__spheres"><td class="mdescLeft">&#160;</td><td class="mdescRight">This namespace contains the structure and functions required for storing internal map projections onto a set of concentric spheres. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_pro_s_h_a_d_e__internal__maths"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html">ProSHADE_internal_maths</a></td></tr>
<tr class="memdesc:namespace_pro_s_h_a_d_e__internal__maths"><td class="mdescLeft">&#160;</td><td class="mdescRight">This namespace contains the internal functions for common mathematical operations. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0cbbac6da7eaf965ee286850344c51e7"><td class="memItemLeft" align="right" valign="top"><a id="a0cbbac6da7eaf965ee286850344c51e7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>zgesdd_</b> (char *jobz, int *m, int *n, std::complex&lt; double &gt; *a, int *lda, double *s, std::complex&lt; double &gt; *u, int *ldu, std::complex&lt; double &gt; *vt, int *ldvt, std::complex&lt; double &gt; *work, int *lwork, double *rwork, int *iwork, int *info)</td></tr>
<tr class="separator:a0cbbac6da7eaf965ee286850344c51e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254fece06e1cfce122a11ddea4f71970"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a254fece06e1cfce122a11ddea4f71970">ProSHADE_internal_maths::complexMultiplication</a> (proshade_double *r1, proshade_double *i1, proshade_double *r2, proshade_double *i2, proshade_double *retReal, proshade_double *retImag)</td></tr>
<tr class="memdesc:a254fece06e1cfce122a11ddea4f71970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to multiply two complex numbers.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a254fece06e1cfce122a11ddea4f71970">More...</a><br /></td></tr>
<tr class="separator:a254fece06e1cfce122a11ddea4f71970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca5a3aedba75f52aaf707edc4e790f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ca5a3aedba75f52aaf707edc4e790f7">ProSHADE_internal_maths::complexMultiplicationConjug</a> (proshade_double *r1, proshade_double *i1, proshade_double *r2, proshade_double *i2, proshade_double *retReal, proshade_double *retImag)</td></tr>
<tr class="memdesc:a2ca5a3aedba75f52aaf707edc4e790f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to multiply two complex numbers by using the second number's conjugate.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ca5a3aedba75f52aaf707edc4e790f7">More...</a><br /></td></tr>
<tr class="separator:a2ca5a3aedba75f52aaf707edc4e790f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b05344ffead449c29a333a57b404f6"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#ac9b05344ffead449c29a333a57b404f6">ProSHADE_internal_maths::complexMultiplicationRealOnly</a> (proshade_double *r1, proshade_double *i1, proshade_double *r2, proshade_double *i2)</td></tr>
<tr class="memdesc:ac9b05344ffead449c29a333a57b404f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to multiply two complex numbers and return the real part only.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#ac9b05344ffead449c29a333a57b404f6">More...</a><br /></td></tr>
<tr class="separator:ac9b05344ffead449c29a333a57b404f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc59a55f5ed21de90e351005c58a871e"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#abc59a55f5ed21de90e351005c58a871e">ProSHADE_internal_maths::complexMultiplicationConjugRealOnly</a> (proshade_double *r1, proshade_double *i1, proshade_double *r2, proshade_double *i2)</td></tr>
<tr class="memdesc:abc59a55f5ed21de90e351005c58a871e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to conjuggate multiply two complex numbers and return the real part only.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#abc59a55f5ed21de90e351005c58a871e">More...</a><br /></td></tr>
<tr class="separator:abc59a55f5ed21de90e351005c58a871e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7c6330e101fb6d729aaf6f545db9c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a8a7c6330e101fb6d729aaf6f545db9c8">ProSHADE_internal_maths::vectorMeanAndSD</a> (std::vector&lt; proshade_double &gt; *vec, proshade_double *&amp;ret)</td></tr>
<tr class="memdesc:a8a7c6330e101fb6d729aaf6f545db9c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get vector mean and standard deviation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a8a7c6330e101fb6d729aaf6f545db9c8">More...</a><br /></td></tr>
<tr class="separator:a8a7c6330e101fb6d729aaf6f545db9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af185ca14eb5d82fb126092767746e00a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#af185ca14eb5d82fb126092767746e00a">ProSHADE_internal_maths::vectorMedianAndIQR</a> (std::vector&lt; proshade_double &gt; *vec, proshade_double *&amp;ret)</td></tr>
<tr class="memdesc:af185ca14eb5d82fb126092767746e00a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get vector median and inter-quartile range.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#af185ca14eb5d82fb126092767746e00a">More...</a><br /></td></tr>
<tr class="separator:af185ca14eb5d82fb126092767746e00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a356017340781739a3bd66c716cfa5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#aa5a356017340781739a3bd66c716cfa5">ProSHADE_internal_maths::arrayMedianAndIQR</a> (proshade_double *vec, proshade_unsign vecSize, proshade_double *&amp;ret)</td></tr>
<tr class="memdesc:aa5a356017340781739a3bd66c716cfa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to get array median and inter-quartile range.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#aa5a356017340781739a3bd66c716cfa5">More...</a><br /></td></tr>
<tr class="separator:aa5a356017340781739a3bd66c716cfa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894d87e94446db04492b663e54a74bff"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a894d87e94446db04492b663e54a74bff">ProSHADE_internal_maths::pearsonCorrCoeff</a> (proshade_double *valSet1, proshade_double *valSet2, proshade_unsign length)</td></tr>
<tr class="memdesc:a894d87e94446db04492b663e54a74bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for computing the Pearson's correlation coefficient.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a894d87e94446db04492b663e54a74bff">More...</a><br /></td></tr>
<tr class="separator:a894d87e94446db04492b663e54a74bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2f7de1bba288270ce2cc772d28d065"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a6e2f7de1bba288270ce2cc772d28d065">ProSHADE_internal_maths::getLegendreAbscAndWeights</a> (proshade_unsign order, proshade_double *abscissas, proshade_double *weights, proshade_unsign taylorSeriesCap)</td></tr>
<tr class="memdesc:a6e2f7de1bba288270ce2cc772d28d065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to prepare abscissas and weights for Gauss-Legendre integration.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a6e2f7de1bba288270ce2cc772d28d065">More...</a><br /></td></tr>
<tr class="separator:a6e2f7de1bba288270ce2cc772d28d065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affab74b910cda2ee3faa461740a7a432"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#affab74b910cda2ee3faa461740a7a432">ProSHADE_internal_maths::getGLPolyAtZero</a> (proshade_unsign order, proshade_double *polyValue, proshade_double *deriValue)</td></tr>
<tr class="memdesc:affab74b910cda2ee3faa461740a7a432"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function obtains the Legendre polynomial values and its derivative at zero for any positive integer order polynomial.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#affab74b910cda2ee3faa461740a7a432">More...</a><br /></td></tr>
<tr class="separator:affab74b910cda2ee3faa461740a7a432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1823adaca871244e42347ecb8ed834a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a1823adaca871244e42347ecb8ed834a2">ProSHADE_internal_maths::getGLFirstEvenRoot</a> (proshade_double polyAtZero, proshade_unsign order, proshade_double *abscAtZero, proshade_double *weighAtZero, proshade_unsign taylorSeriesCap)</td></tr>
<tr class="memdesc:a1823adaca871244e42347ecb8ed834a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds the first root for Legendre polynomials of odd order.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a1823adaca871244e42347ecb8ed834a2">More...</a><br /></td></tr>
<tr class="separator:a1823adaca871244e42347ecb8ed834a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e69b64278319ae1a1268d1a55545675"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a7e69b64278319ae1a1268d1a55545675">ProSHADE_internal_maths::evaluateGLSeries</a> (proshade_double *series, proshade_double target, proshade_unsign terms)</td></tr>
<tr class="memdesc:a7e69b64278319ae1a1268d1a55545675"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function evaluates the Taylor expansion.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a7e69b64278319ae1a1268d1a55545675">More...</a><br /></td></tr>
<tr class="separator:a7e69b64278319ae1a1268d1a55545675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2619c7f3b8d628af9cb356778e9807"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a4f2619c7f3b8d628af9cb356778e9807">ProSHADE_internal_maths::advanceGLPolyValue</a> (proshade_double from, proshade_double to, proshade_double valAtFrom, proshade_unsign noSteps, proshade_unsign taylorSeriesCap)</td></tr>
<tr class="memdesc:a4f2619c7f3b8d628af9cb356778e9807"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds the next value of the polynomial.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a4f2619c7f3b8d628af9cb356778e9807">More...</a><br /></td></tr>
<tr class="separator:a4f2619c7f3b8d628af9cb356778e9807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c91064de64aef9f8278d533f8188ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a31c91064de64aef9f8278d533f8188ad">ProSHADE_internal_maths::completeLegendreSeries</a> (proshade_unsign order, proshade_double *abscissa, proshade_double *weights, proshade_unsign taylorSeriesCap)</td></tr>
<tr class="memdesc:a31c91064de64aef9f8278d533f8188ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function completes the Legendre polynomial series assuming you have obtained the first values.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a31c91064de64aef9f8278d533f8188ad">More...</a><br /></td></tr>
<tr class="separator:a31c91064de64aef9f8278d533f8188ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62133f51851217e3cb28dff2f520d192"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a62133f51851217e3cb28dff2f520d192">ProSHADE_internal_maths::gaussLegendreIntegrationReal</a> (proshade_double *vals, proshade_unsign valsSize, proshade_unsign order, proshade_double *abscissas, proshade_double *weights, proshade_double integralOverRange, proshade_double maxSphereDists)</td></tr>
<tr class="memdesc:a62133f51851217e3cb28dff2f520d192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute real part of the Gauss-Legendre integration over spherical harmonic values in different shells.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a62133f51851217e3cb28dff2f520d192">More...</a><br /></td></tr>
<tr class="separator:a62133f51851217e3cb28dff2f520d192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4604176a61820f5fcb95e372861c1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a3d4604176a61820f5fcb95e372861c1d">ProSHADE_internal_maths::gaussLegendreIntegration</a> (proshade_complex *vals, proshade_unsign valsSize, proshade_unsign order, proshade_double *abscissas, proshade_double *weights, proshade_double integralOverRange, proshade_double maxSphereDists, proshade_double *retReal, proshade_double *retImag)</td></tr>
<tr class="memdesc:a3d4604176a61820f5fcb95e372861c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute the complete complex Gauss-Legendre integration over spherical harmonic values in different shells.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a3d4604176a61820f5fcb95e372861c1d">More...</a><br /></td></tr>
<tr class="separator:a3d4604176a61820f5fcb95e372861c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98abe6f7fac976a70b608951dbdf993"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#ab98abe6f7fac976a70b608951dbdf993">ProSHADE_internal_maths::complexMatrixSVDSigmasOnly</a> (proshade_complex **mat, int dim, double *&amp;singularValues)</td></tr>
<tr class="memdesc:ab98abe6f7fac976a70b608951dbdf993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute the complete complex matrix SVD and return only the sigmas.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#ab98abe6f7fac976a70b608951dbdf993">More...</a><br /></td></tr>
<tr class="separator:ab98abe6f7fac976a70b608951dbdf993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc79bf2506934c9ebbda9c13a2722ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#acdc79bf2506934c9ebbda9c13a2722ad">ProSHADE_internal_maths::complexMatrixSVDUandVOnly</a> (proshade_double *mat, int dim, proshade_double *uAndV, bool fail=true)</td></tr>
<tr class="memdesc:acdc79bf2506934c9ebbda9c13a2722ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute the real matrix SVD and return the U and V matrices.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#acdc79bf2506934c9ebbda9c13a2722ad">More...</a><br /></td></tr>
<tr class="separator:acdc79bf2506934c9ebbda9c13a2722ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6c5376edac98e54ef0e418cd05d706"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#acf6c5376edac98e54ef0e418cd05d706">ProSHADE_internal_maths::getEulerZXZFromSOFTPosition</a> (proshade_signed band, proshade_signed x, proshade_signed y, proshade_signed z, proshade_double *eulerAlpha, proshade_double *eulerBeta, proshade_double *eulerGamma)</td></tr>
<tr class="memdesc:acf6c5376edac98e54ef0e418cd05d706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to find Euler angles (ZXZ convention) from index position in the inverse SOFT map.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#acf6c5376edac98e54ef0e418cd05d706">More...</a><br /></td></tr>
<tr class="separator:acf6c5376edac98e54ef0e418cd05d706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea245a9b2b305f970be1ed62b141cce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#adea245a9b2b305f970be1ed62b141cce">ProSHADE_internal_maths::getSOFTPositionFromEulerZXZ</a> (proshade_signed band, proshade_double eulerAlpha, proshade_double eulerBeta, proshade_double eulerGamma, proshade_double *x, proshade_double *y, proshade_double *z)</td></tr>
<tr class="memdesc:adea245a9b2b305f970be1ed62b141cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to find the index position in the inverse SOFT map from given Euler angles (ZXZ convention).  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#adea245a9b2b305f970be1ed62b141cce">More...</a><br /></td></tr>
<tr class="separator:adea245a9b2b305f970be1ed62b141cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd9fe573a48f499dd7d1df4f779222f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#abd9fe573a48f499dd7d1df4f779222f1">ProSHADE_internal_maths::getRotationMatrixFromEulerZXZAngles</a> (proshade_double eulerAlpha, proshade_double eulerBeta, proshade_double eulerGamma, proshade_double *matrix)</td></tr>
<tr class="memdesc:abd9fe573a48f499dd7d1df4f779222f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to find the rotation matrix from Euler angles (ZXZ convention).  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#abd9fe573a48f499dd7d1df4f779222f1">More...</a><br /></td></tr>
<tr class="separator:abd9fe573a48f499dd7d1df4f779222f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc6f1626c7463de53c9f4f6fa11db22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#aafc6f1626c7463de53c9f4f6fa11db22">ProSHADE_internal_maths::getAxisAngleFromRotationMatrix</a> (proshade_double *rotMat, proshade_double *x, proshade_double *y, proshade_double *z, proshade_double *ang)</td></tr>
<tr class="memdesc:aafc6f1626c7463de53c9f4f6fa11db22"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts rotation matrix to the axis-angle representation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#aafc6f1626c7463de53c9f4f6fa11db22">More...</a><br /></td></tr>
<tr class="separator:aafc6f1626c7463de53c9f4f6fa11db22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a379ad8635541b0c7f7f6349822b2a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a4a379ad8635541b0c7f7f6349822b2a4">ProSHADE_internal_maths::getAxisAngleFromRotationMatrix</a> (std::vector&lt; proshade_double &gt; *rotMat, proshade_double *x, proshade_double *y, proshade_double *z, proshade_double *ang)</td></tr>
<tr class="memdesc:a4a379ad8635541b0c7f7f6349822b2a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts rotation matrix to the axis-angle representation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a4a379ad8635541b0c7f7f6349822b2a4">More...</a><br /></td></tr>
<tr class="separator:a4a379ad8635541b0c7f7f6349822b2a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39eafef902a49cc0816a2ed675c14a49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a39eafef902a49cc0816a2ed675c14a49">ProSHADE_internal_maths::getRotationMatrixFromAngleAxis</a> (proshade_double *rotMat, proshade_double x, proshade_double y, proshade_double z, proshade_double ang)</td></tr>
<tr class="memdesc:a39eafef902a49cc0816a2ed675c14a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts the axis-angle representation to the rotation matrix representation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a39eafef902a49cc0816a2ed675c14a49">More...</a><br /></td></tr>
<tr class="separator:a39eafef902a49cc0816a2ed675c14a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f6afcef5b90ca77d7d6a9e91824e28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#ae6f6afcef5b90ca77d7d6a9e91824e28">ProSHADE_internal_maths::getEulerZXZFromRotMatrix</a> (proshade_double *rotMat, proshade_double *eA, proshade_double *eB, proshade_double *eG)</td></tr>
<tr class="memdesc:ae6f6afcef5b90ca77d7d6a9e91824e28"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts rotation matrix to the Euler ZXZ angles representation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#ae6f6afcef5b90ca77d7d6a9e91824e28">More...</a><br /></td></tr>
<tr class="separator:ae6f6afcef5b90ca77d7d6a9e91824e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5750d6f0bf8e4a4b1d26552e8719dfd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a5750d6f0bf8e4a4b1d26552e8719dfd4">ProSHADE_internal_maths::getEulerZXZFromAngleAxis</a> (proshade_double axX, proshade_double axY, proshade_double axZ, proshade_double axAng, proshade_double *eA, proshade_double *eB, proshade_double *eG, proshade_unsign angDim)</td></tr>
<tr class="memdesc:a5750d6f0bf8e4a4b1d26552e8719dfd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts angle-axis representation to the Euler ZXZ angles representation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a5750d6f0bf8e4a4b1d26552e8719dfd4">More...</a><br /></td></tr>
<tr class="separator:a5750d6f0bf8e4a4b1d26552e8719dfd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ade24485a9272a2d08dd6efb7a54d83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a0ade24485a9272a2d08dd6efb7a54d83">ProSHADE_internal_maths::getEulerZXZFromAngleAxisFullSearch</a> (proshade_double axX, proshade_double axY, proshade_double axZ, proshade_double axAng, proshade_double *eA, proshade_double *eB, proshade_double *eG, proshade_signed angDim)</td></tr>
<tr class="memdesc:a0ade24485a9272a2d08dd6efb7a54d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function converts angle-axis representation to the Euler ZXZ angles representation using full search.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a0ade24485a9272a2d08dd6efb7a54d83">More...</a><br /></td></tr>
<tr class="separator:a0ade24485a9272a2d08dd6efb7a54d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10bbc3e6e75c26cfbe90664dd2a7d151"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a10bbc3e6e75c26cfbe90664dd2a7d151">ProSHADE_internal_maths::multiplyTwoSquareMatrices</a> (proshade_double *A, proshade_double *B, proshade_double *res, proshade_unsign dim=3)</td></tr>
<tr class="memdesc:a10bbc3e6e75c26cfbe90664dd2a7d151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to compute matrix multiplication.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a10bbc3e6e75c26cfbe90664dd2a7d151">More...</a><br /></td></tr>
<tr class="separator:a10bbc3e6e75c26cfbe90664dd2a7d151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6359dd366cdd986f5ad155bff8235a8e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; proshade_signed &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a6359dd366cdd986f5ad155bff8235a8e">ProSHADE_internal_maths::primeFactorsDecomp</a> (proshade_signed number)</td></tr>
<tr class="memdesc:a6359dd366cdd986f5ad155bff8235a8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to find prime factors of an integer.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a6359dd366cdd986f5ad155bff8235a8e">More...</a><br /></td></tr>
<tr class="separator:a6359dd366cdd986f5ad155bff8235a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01087ea3e0db56758d1771618e2e4a45"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a01087ea3e0db56758d1771618e2e4a45">ProSHADE_internal_maths::normalDistributionValue</a> (proshade_double mean, proshade_double standardDev, proshade_double value)</td></tr>
<tr class="memdesc:a01087ea3e0db56758d1771618e2e4a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to the heiht of normal distribution given by mean and standard deviation for a given value.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a01087ea3e0db56758d1771618e2e4a45">More...</a><br /></td></tr>
<tr class="separator:a01087ea3e0db56758d1771618e2e4a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac3b534f974de25b092e9d48d9f7dea"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ac3b534f974de25b092e9d48d9f7dea">ProSHADE_internal_maths::computeDotProduct</a> (proshade_double *x1, proshade_double *y1, proshade_double *z1, proshade_double *x2, proshade_double *y2, proshade_double *z2)</td></tr>
<tr class="memdesc:a2ac3b534f974de25b092e9d48d9f7dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple 3D vector dot product computation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a2ac3b534f974de25b092e9d48d9f7dea">More...</a><br /></td></tr>
<tr class="separator:a2ac3b534f974de25b092e9d48d9f7dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b37ae1c35d048fd5dbff0a2cfcc4601"><td class="memItemLeft" align="right" valign="top">proshade_double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a3b37ae1c35d048fd5dbff0a2cfcc4601">ProSHADE_internal_maths::computeDotProduct</a> (proshade_double x1, proshade_double y1, proshade_double z1, proshade_double x2, proshade_double y2, proshade_double z2)</td></tr>
<tr class="memdesc:a3b37ae1c35d048fd5dbff0a2cfcc4601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple 3D vector dot product computation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a3b37ae1c35d048fd5dbff0a2cfcc4601">More...</a><br /></td></tr>
<tr class="separator:a3b37ae1c35d048fd5dbff0a2cfcc4601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61807efeb86ea021f3d17ac531911c3c"><td class="memItemLeft" align="right" valign="top">proshade_double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a61807efeb86ea021f3d17ac531911c3c">ProSHADE_internal_maths::computeCrossProduct</a> (proshade_double *x1, proshade_double *y1, proshade_double *z1, proshade_double *x2, proshade_double *y2, proshade_double *z2)</td></tr>
<tr class="memdesc:a61807efeb86ea021f3d17ac531911c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple 3D vector cross product computation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a61807efeb86ea021f3d17ac531911c3c">More...</a><br /></td></tr>
<tr class="separator:a61807efeb86ea021f3d17ac531911c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f2b9b9da97b52b7e5cccc08493d0e0d"><td class="memItemLeft" align="right" valign="top">proshade_double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a5f2b9b9da97b52b7e5cccc08493d0e0d">ProSHADE_internal_maths::compute3x3MatrixMultiplication</a> (proshade_double *mat1, proshade_double *mat2)</td></tr>
<tr class="memdesc:a5f2b9b9da97b52b7e5cccc08493d0e0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for computing a 3x3 matrix multiplication.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a5f2b9b9da97b52b7e5cccc08493d0e0d">More...</a><br /></td></tr>
<tr class="separator:a5f2b9b9da97b52b7e5cccc08493d0e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9c7716f6ab682e8548ab77efcdc444"><td class="memItemLeft" align="right" valign="top">proshade_double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2f9c7716f6ab682e8548ab77efcdc444">ProSHADE_internal_maths::compute3x3MatrixVectorMultiplication</a> (proshade_double *mat, proshade_double x, proshade_double y, proshade_double z)</td></tr>
<tr class="memdesc:a2f9c7716f6ab682e8548ab77efcdc444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for computing a 3x3 matrix to 3x1 vector multiplication.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a2f9c7716f6ab682e8548ab77efcdc444">More...</a><br /></td></tr>
<tr class="separator:a2f9c7716f6ab682e8548ab77efcdc444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ac617b105e1ca1729800c5f290b567"><td class="memItemLeft" align="right" valign="top">proshade_double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a83ac617b105e1ca1729800c5f290b567">ProSHADE_internal_maths::compute3x3MatrixInverse</a> (proshade_double *mat)</td></tr>
<tr class="memdesc:a83ac617b105e1ca1729800c5f290b567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for computing a 3x3 matrix inverse.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a83ac617b105e1ca1729800c5f290b567">More...</a><br /></td></tr>
<tr class="separator:a83ac617b105e1ca1729800c5f290b567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c48ee69a642f279354789f09b02296"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#ac6c48ee69a642f279354789f09b02296">ProSHADE_internal_maths::transpose3x3MatrixInPlace</a> (proshade_double *mat)</td></tr>
<tr class="memdesc:ac6c48ee69a642f279354789f09b02296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes 3x3 matrix in place.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#ac6c48ee69a642f279354789f09b02296">More...</a><br /></td></tr>
<tr class="separator:ac6c48ee69a642f279354789f09b02296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b17617f8b3c42c5199948828cd1a57b"><td class="memItemLeft" align="right" valign="top">proshade_double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2b17617f8b3c42c5199948828cd1a57b">ProSHADE_internal_maths::findRotMatMatchingVectors</a> (proshade_double x1, proshade_double y1, proshade_double z1, proshade_double x2, proshade_double y2, proshade_double z2)</td></tr>
<tr class="memdesc:a2b17617f8b3c42c5199948828cd1a57b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computation of rotation matrix rotating one vector onto the other.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a2b17617f8b3c42c5199948828cd1a57b">More...</a><br /></td></tr>
<tr class="separator:a2b17617f8b3c42c5199948828cd1a57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45fbcfaeaabf9bae2fbd7d46a5fb4bc7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; proshade_double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a45fbcfaeaabf9bae2fbd7d46a5fb4bc7">ProSHADE_internal_maths::findVectorFromTwoVAndTwoD</a> (proshade_double x1, proshade_double y1, proshade_double z1, proshade_double x2, proshade_double y2, proshade_double z2, proshade_double dot1, proshade_double dot2)</td></tr>
<tr class="memdesc:a45fbcfaeaabf9bae2fbd7d46a5fb4bc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for finding a vector which would have a given two dot products to two other vectors.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a45fbcfaeaabf9bae2fbd7d46a5fb4bc7">More...</a><br /></td></tr>
<tr class="separator:a45fbcfaeaabf9bae2fbd7d46a5fb4bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f376bb341b192fff008b9b4ef5c603"><td class="memItemLeft" align="right" valign="top">std::vector&lt; proshade_double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#ae9f376bb341b192fff008b9b4ef5c603">ProSHADE_internal_maths::findVectorFromThreeVAndThreeD</a> (proshade_double x1, proshade_double y1, proshade_double z1, proshade_double x2, proshade_double y2, proshade_double z2, proshade_double x3, proshade_double y3, proshade_double z3, proshade_double dot1, proshade_double dot2, proshade_double dot3)</td></tr>
<tr class="memdesc:ae9f376bb341b192fff008b9b4ef5c603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for finding a vector which would have a given three dot products to three other vectors.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#ae9f376bb341b192fff008b9b4ef5c603">More...</a><br /></td></tr>
<tr class="separator:ae9f376bb341b192fff008b9b4ef5c603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18222a942e5fff8eecd15f1235c609e1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; proshade_double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a18222a942e5fff8eecd15f1235c609e1">ProSHADE_internal_maths::multiplyGroupElementMatrices</a> (std::vector&lt; proshade_double &gt; *el1, std::vector&lt; proshade_double &gt; *el2)</td></tr>
<tr class="memdesc:a18222a942e5fff8eecd15f1235c609e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function computes matrix multiplication using the ProSHADE group element matrix format as input and output.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a18222a942e5fff8eecd15f1235c609e1">More...</a><br /></td></tr>
<tr class="separator:a18222a942e5fff8eecd15f1235c609e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4348a7a36275c9cea20b5c27093c9b7e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a4348a7a36275c9cea20b5c27093c9b7e">ProSHADE_internal_maths::rotationMatrixSimilarity</a> (std::vector&lt; proshade_double &gt; *mat1, std::vector&lt; proshade_double &gt; *mat2, proshade_double tolerance=0.1)</td></tr>
<tr class="memdesc:a4348a7a36275c9cea20b5c27093c9b7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function compares the distance between two rotation matrices and decides if they are similar using tolerance.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a4348a7a36275c9cea20b5c27093c9b7e">More...</a><br /></td></tr>
<tr class="separator:a4348a7a36275c9cea20b5c27093c9b7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2f67cba1eea57f19fdaf062db74fde"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2b2f67cba1eea57f19fdaf062db74fde">ProSHADE_internal_maths::vectorOrientationSimilarity</a> (proshade_double a1, proshade_double a2, proshade_double a3, proshade_double b1, proshade_double b2, proshade_double b3, proshade_double tolerance=0.1)</td></tr>
<tr class="memdesc:a2b2f67cba1eea57f19fdaf062db74fde"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function compares two vectors using cosine distance and decides if they are similar using tolerance.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a2b2f67cba1eea57f19fdaf062db74fde">More...</a><br /></td></tr>
<tr class="separator:a2b2f67cba1eea57f19fdaf062db74fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e789452e327bb07a53c5358f4d3eb0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a79e789452e327bb07a53c5358f4d3eb0">ProSHADE_internal_maths::vectorOrientationSimilaritySameDirection</a> (proshade_double a1, proshade_double a2, proshade_double a3, proshade_double b1, proshade_double b2, proshade_double b3, proshade_double tolerance=0.1)</td></tr>
<tr class="memdesc:a79e789452e327bb07a53c5358f4d3eb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function compares two vectors using cosine distance and decides if they are similar using tolerance.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a79e789452e327bb07a53c5358f4d3eb0">More...</a><br /></td></tr>
<tr class="separator:a79e789452e327bb07a53c5358f4d3eb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51486f6276c28c1b503f19c36007b9e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a51486f6276c28c1b503f19c36007b9e2">ProSHADE_internal_maths::optimiseAxisBiCubicInterpolation</a> (proshade_double *bestLattitude, proshade_double *bestLongitude, proshade_double *bestSum, std::vector&lt; proshade_unsign &gt; *sphereList, std::vector&lt; <a class="el" href="class_pro_s_h_a_d_e__internal__spheres_1_1_pro_s_h_a_d_e__rot_fun__sphere.html">ProSHADE_internal_spheres::ProSHADE_rotFun_sphere</a> * &gt; *sphereMappedRotFun, proshade_double step=0.05)</td></tr>
<tr class="memdesc:a51486f6276c28c1b503f19c36007b9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function provides axis optimisation given starting lattitude and longitude indices.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a51486f6276c28c1b503f19c36007b9e2">More...</a><br /></td></tr>
<tr class="separator:a51486f6276c28c1b503f19c36007b9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac027bbd2cde68eb9d677e8b11b90cc2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#ac027bbd2cde68eb9d677e8b11b90cc2e">ProSHADE_internal_maths::prepareBiCubicInterpolatorsMinusMinus</a> (proshade_double bestLattitude, proshade_double bestLongitude, std::vector&lt; proshade_unsign &gt; *sphereList, std::vector&lt; <a class="el" href="class_pro_s_h_a_d_e__internal__maths_1_1_bicubic_interpolator.html">ProSHADE_internal_maths::BicubicInterpolator</a> * &gt; *interpols, std::vector&lt; <a class="el" href="class_pro_s_h_a_d_e__internal__spheres_1_1_pro_s_h_a_d_e__rot_fun__sphere.html">ProSHADE_internal_spheres::ProSHADE_rotFun_sphere</a> * &gt; *sphereMappedRotFun)</td></tr>
<tr class="memdesc:ac027bbd2cde68eb9d677e8b11b90cc2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function prepares the interpolation objects for the bi-cubic interpolation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#ac027bbd2cde68eb9d677e8b11b90cc2e">More...</a><br /></td></tr>
<tr class="separator:ac027bbd2cde68eb9d677e8b11b90cc2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c2321ffcef5079634493d9bf65749b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a73c2321ffcef5079634493d9bf65749b">ProSHADE_internal_maths::prepareBiCubicInterpolatorsMinusPlus</a> (proshade_double bestLattitude, proshade_double bestLongitude, std::vector&lt; proshade_unsign &gt; *sphereList, std::vector&lt; <a class="el" href="class_pro_s_h_a_d_e__internal__maths_1_1_bicubic_interpolator.html">ProSHADE_internal_maths::BicubicInterpolator</a> * &gt; *interpols, std::vector&lt; <a class="el" href="class_pro_s_h_a_d_e__internal__spheres_1_1_pro_s_h_a_d_e__rot_fun__sphere.html">ProSHADE_internal_spheres::ProSHADE_rotFun_sphere</a> * &gt; *sphereMappedRotFun)</td></tr>
<tr class="memdesc:a73c2321ffcef5079634493d9bf65749b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function prepares the interpolation objects for the bi-cubic interpolation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a73c2321ffcef5079634493d9bf65749b">More...</a><br /></td></tr>
<tr class="separator:a73c2321ffcef5079634493d9bf65749b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f12eb80331377a36ee6b3a4f8e65147"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a3f12eb80331377a36ee6b3a4f8e65147">ProSHADE_internal_maths::prepareBiCubicInterpolatorsPlusMinus</a> (proshade_double bestLattitude, proshade_double bestLongitude, std::vector&lt; proshade_unsign &gt; *sphereList, std::vector&lt; <a class="el" href="class_pro_s_h_a_d_e__internal__maths_1_1_bicubic_interpolator.html">ProSHADE_internal_maths::BicubicInterpolator</a> * &gt; *interpols, std::vector&lt; <a class="el" href="class_pro_s_h_a_d_e__internal__spheres_1_1_pro_s_h_a_d_e__rot_fun__sphere.html">ProSHADE_internal_spheres::ProSHADE_rotFun_sphere</a> * &gt; *sphereMappedRotFun)</td></tr>
<tr class="memdesc:a3f12eb80331377a36ee6b3a4f8e65147"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function prepares the interpolation objects for the bi-cubic interpolation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a3f12eb80331377a36ee6b3a4f8e65147">More...</a><br /></td></tr>
<tr class="separator:a3f12eb80331377a36ee6b3a4f8e65147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b355465dd2244b51e579dcb8669b3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#ac3b355465dd2244b51e579dcb8669b3a">ProSHADE_internal_maths::prepareBiCubicInterpolatorsPlusPlus</a> (proshade_double bestLattitude, proshade_double bestLongitude, std::vector&lt; proshade_unsign &gt; *sphereList, std::vector&lt; <a class="el" href="class_pro_s_h_a_d_e__internal__maths_1_1_bicubic_interpolator.html">ProSHADE_internal_maths::BicubicInterpolator</a> * &gt; *interpols, std::vector&lt; <a class="el" href="class_pro_s_h_a_d_e__internal__spheres_1_1_pro_s_h_a_d_e__rot_fun__sphere.html">ProSHADE_internal_spheres::ProSHADE_rotFun_sphere</a> * &gt; *sphereMappedRotFun)</td></tr>
<tr class="memdesc:ac3b355465dd2244b51e579dcb8669b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function prepares the interpolation objects for the bi-cubic interpolation.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#ac3b355465dd2244b51e579dcb8669b3a">More...</a><br /></td></tr>
<tr class="separator:ac3b355465dd2244b51e579dcb8669b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2380a3710f7dbe672519c3adda30f7cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2380a3710f7dbe672519c3adda30f7cd">ProSHADE_internal_maths::isAxisUnique</a> (std::vector&lt; proshade_double * &gt; *CSymList, proshade_double *axis, proshade_double tolerance=0.1, bool improve=false)</td></tr>
<tr class="memdesc:a2380a3710f7dbe672519c3adda30f7cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if new axis is unique, or already detected.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a2380a3710f7dbe672519c3adda30f7cd">More...</a><br /></td></tr>
<tr class="separator:a2380a3710f7dbe672519c3adda30f7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f093fbdd34498d27a4d8998b620c91"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a49f093fbdd34498d27a4d8998b620c91">ProSHADE_internal_maths::isAxisUnique</a> (std::vector&lt; proshade_double * &gt; *CSymList, proshade_double X, proshade_double Y, proshade_double Z, proshade_double fold, proshade_double tolerance)</td></tr>
<tr class="memdesc:a49f093fbdd34498d27a4d8998b620c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if new axis is unique, or already detected.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a49f093fbdd34498d27a4d8998b620c91">More...</a><br /></td></tr>
<tr class="separator:a49f093fbdd34498d27a4d8998b620c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2454c19169bb38d616e52b99f1dc4495"><td class="memItemLeft" align="right" valign="top">std::vector&lt; proshade_unsign &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html#a2454c19169bb38d616e52b99f1dc4495">ProSHADE_internal_maths::findAllPrimes</a> (proshade_unsign upTo)</td></tr>
<tr class="memdesc:a2454c19169bb38d616e52b99f1dc4495"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds all prime numbers up to the supplied limit.  <a href="namespace_pro_s_h_a_d_e__internal__maths.html#a2454c19169bb38d616e52b99f1dc4495">More...</a><br /></td></tr>
<tr class="separator:a2454c19169bb38d616e52b99f1dc4495"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This header file declares all the functions required for computing various information from the ProSHADE data. </p>
<p>This header file declares the <a class="el" href="namespace_pro_s_h_a_d_e__internal__maths.html" title="This namespace contains the internal functions for common mathematical operations.">ProSHADE_internal_maths</a> namespace, which groups all the functions required to computed various information from the specific ProSHADE data and its organisation. The functionalities available here include complex number computations, rotation representation conversions as well as Gauss-Legendre integration or Taylor series approximation.</p>
<p>Copyright by Michal Tykac and individual contributors. All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: 1) Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. 2) Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. 3) Neither the name of Michal Tykac nor the names of this code's contributors may be used to endorse or promote products derived from this software without specific prior written permission.</p>
<p>This software is provided by the copyright holder and contributors "as is" and any express or implied warranties, including, but not limitted to, the implied warranties of merchantibility and fitness for a particular purpose are disclaimed. In no event shall the copyright owner or the contributors be liable for any direct, indirect, incidental, special, exemplary, or consequential damages (including, but not limitted to, procurement of substitute goods or services, loss of use, data or profits, or business interuption) however caused and on any theory of liability, whether in contract, strict liability or tort (including negligence or otherwise) arising in any way out of the use of this software, even if advised of the possibility of such damage.</p>
<dl class="section author"><dt>Author</dt><dd>Michal Tykac </dd>
<dd>
Garib N. Murshudov </dd></dl>
<dl class="section version"><dt>Version</dt><dd>0.7.5.4 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>MAR 2021 </dd></dl>

<p class="definition">Definition in file <a class="el" href="_pro_s_h_a_d_e__maths_8hpp_source.html">ProSHADE_maths.hpp</a>.</p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_fa9be34cc2c3eb9c0decdfb277595ca7.html">proshade</a></li><li class="navelem"><a class="el" href="_pro_s_h_a_d_e__maths_8hpp.html">ProSHADE_maths.hpp</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
